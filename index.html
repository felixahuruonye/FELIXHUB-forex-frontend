<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FELIXHUB Forex Time Zone</title>
  <style>
    body {
      font-family: "Poppins", sans-serif;
      background: #f3f7fa;
      color: #333;
      margin: 0;
      padding: 0;
      text-align: center;
    }

    header {
      background: #004aad;
      color: white;
      padding: 1rem 0;
      font-size: 1.5rem;
      font-weight: bold;
      letter-spacing: 1px;
      text-transform: uppercase;
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
    }

    .container {
      max-width: 600px;
      margin: 30px auto;
      background: white;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
    }

    .country-box {
      margin-bottom: 20px;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 8px;
    }

    input, select, button {
      padding: 10px;
      margin: 8px;
      width: 90%;
      border: 1px solid #ccc;
      border-radius: 6px;
    }

    button {
      background-color: #004aad;
      color: white;
      cursor: pointer;
      font-weight: bold;
    }

    button:hover {
      background-color: #003580;
    }

    .result-card {
      background: #f1f5ff;
      padding: 12px;
      border-radius: 8px;
      margin-top: 10px;
      border-left: 5px solid #004aad;
      text-align: left;
    }

    .premium-box {
      background: #e9f9ec;
      border: 1px solid #00964d;
      border-left: 5px solid #00964d;
      padding: 15px;
      margin-top: 15px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <header>üåç FELIXHUB Forex Time Zone</header>

  <div class="container">
    <h3>Check Real-Time for Any Country</h3>

    <div id="countryFormContainer">
      <div class="country-box">
        <select class="continent">
          <option value="">Select Continent</option>
          <option>Africa</option>
          <option>Asia</option>
          <option>Europe</option>
          <option>North America</option>
          <option>South America</option>
          <option>Oceania</option>
        </select>
        <input type="text" placeholder="Country (e.g. Nigeria)" class="country" />
        <input type="text" placeholder="City (e.g. Lagos)" class="city" />
      </div>
    </div>

    <button id="addCountry">+ Add Another Country</button>
    <button id="getTime">Get Time</button>
    <button id="useMyIP">Use My IP</button>

    <div id="results"></div>

    <div id="premiumPrompt" class="premium-box" style="display:none;">
      <h4>Upgrade to Premium üåü</h4>
      <p>Unlock more continents, zip codes, and forex tools by subscribing!</p>
      <a id="paystackLink" href="https://paystack.shop/pay/felixhub-premium" target="_blank">
        <button>Upgrade with Paystack</button>
      </a>
    </div>
  </div>

  <script>
    const resultsDiv = document.getElementById("results");
    const addCountryBtn = document.getElementById("addCountry");
    const getTimeBtn = document.getElementById("getTime");
    const useMyIPBtn = document.getElementById("useMyIP");
    const premiumPrompt = document.getElementById("premiumPrompt");
    const paystackLink = document.getElementById("paystackLink");
    let searchCount = 0;
    let liveIntervals = [];

    // Keep UI exactly the same; just improve logic
    addCountryBtn.addEventListener("click", () => {
      const container = document.createElement("div");
      container.classList.add("country-box");
      container.innerHTML = `
        <select class="continent">
          <option value="">Select Continent</option>
          <option>Africa</option>
          <option>Asia</option>
          <option>Europe</option>
          <option>North America</option>
          <option>South America</option>
          <option>Oceania</option>
        </select>
        <input type="text" placeholder="Country (e.g. USA)" class="country" />
        <input type="text" placeholder="City (e.g. New York)" class="city" />
      `;
      document.getElementById("countryFormContainer").appendChild(container);
    });

    // Helpers
    function mapContinent(input) {
      if (!input) return "";
      const v = input.toLowerCase();
      if (v.includes("america")) return "America";
      if (v.includes("oceania")) return "Pacific";
      if (v.includes("antarctica")) return "Antarctica";
      // Africa, Asia, Europe keep same capitalized first letter
      return input.charAt(0).toUpperCase() + input.slice(1);
    }

    function normalizeCityName(str) {
      if (!str) return "";
      // Remove commas, dots; collapse spaces; title-case words and join with underscore
      return str
        .replace(/[.,]/g, " ")
        .trim()
        .split(/\s+/)
        .map(s => s.charAt(0).toUpperCase() + s.slice(1))
        .join("_");
    }

    async function fetchZonesList() {
      try {
        const r = await fetch("https://worldtimeapi.org/api/timezone");
        if (!r.ok) return [];
        return await r.json();
      } catch {
        return [];
      }
    }

    // Try match with zones list first to get timezone name
    function findZoneMatch(zones, continent, city, country) {
      const cityNorm = city ? city.toLowerCase() : "";
      const countryNorm = country ? country.toLowerCase() : "";
      const continentMapped = continent ? mapContinent(continent) : "";

      // 1) Exact candidate: Continent/CityNormalized
      if (continentMapped && city) {
        const candidate = `${continentMapped}/${normalizeCityName(city)}`;
        const foundExact = zones.find(z => z.toLowerCase() === candidate.toLowerCase());
        if (foundExact) return foundExact;
      }

      // 2) Match where last segment equals city
      const foundByLast = zones.find(z => {
        const parts = z.split("/");
        const last = parts[parts.length - 1].toLowerCase();
        return last === cityNorm || last === normalizeCityName(city).toLowerCase();
      });
      if (foundByLast) return foundByLast;

      // 3) Contains city or country
      const foundContain = zones.find(z => z.toLowerCase().includes(cityNorm) || z.toLowerCase().includes(countryNorm));
      if (foundContain) return foundContain;

      // 4) Match by continent then contains
      if (continentMapped) {
        const foundCont = zones.find(z => z.toLowerCase().startsWith(continentMapped.toLowerCase()) && (z.toLowerCase().includes(cityNorm) || z.toLowerCase().includes(countryNorm)));
        if (foundCont) return foundCont;
      }

      return null;
    }

    // Fallback: geocode via Nominatim + timeapi.io coordinate endpoint
    async function timeByGeocode(query) {
      try {
        const nom = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(query)}`, {
          headers: { "User-Agent": "FelixHub-Time-App/1.0" }
        });
        if (!nom.ok) return null;
        const places = await nom.json();
        if (!places || places.length === 0) return null;
        const p = places[0];
        const lat = p.lat;
        const lon = p.lon;
        // timeapi.io coordinate endpoint
        const t = await fetch(`https://timeapi.io/api/Time/current/coordinate?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}`);
        if (!t.ok) return null;
        const tj = await t.json();
        // timeapi returns dateTime and timeZone
        return {
          provider: "timeapi",
          timezone: tj.timeZone || tj.timezone || null,
          datetime: tj.dateTime || tj.date_time || tj.dateTimeUTC || null,
          raw: tj
        };
      } catch {
        return null;
      }
    }

    // Create live clock element that updates every second using timezone name (if available)
    function createLiveClockElement(title, timezoneName, startIso) {
      const card = document.createElement("div");
      card.classList.add("result-card");
      const clockId = `clock-${Math.random().toString(36).slice(2,9)}`;
      card.innerHTML = `<strong>${title}</strong><br>Timezone: ${timezoneName || "unknown"}<br><span id="${clockId}">Loading...</span>`;
      resultsDiv.appendChild(card);

      // Use timezoneName if available to format. Start time from startIso or current time.
      let currentMs = startIso ? Date.parse(startIso) : Date.now();

      function update() {
        // Use toLocaleString with timezone if provided
        try {
          if (timezoneName) {
            const formatted = new Date(currentMs).toLocaleString("en-US", { timeZone: timezoneName });
            document.getElementById(clockId).textContent = `Local Time: ${formatted}`;
          } else {
            document.getElementById(clockId).textContent = `Local Time: ${new Date(currentMs).toLocaleString()}`;
          }
        } catch {
          document.getElementById(clockId).textContent = `Local Time: ${new Date(currentMs).toLocaleString()}`;
        }
        currentMs += 1000;
      }

      update();
      const iv = setInterval(update, 1000);
      liveIntervals.push(iv);
    }

    async function handleSingleLocation(continent, country, city) {
      // Try worldtimeapi zone match
      const zones = await fetchZonesList();
      const zone = findZoneMatch(zones, continent, city, country);
      if (zone) {
        // get timezone data
        try {
          const r = await fetch(`https://worldtimeapi.org/api/timezone/${encodeURIComponent(zone)}`);
          if (r.ok) {
            const j = await r.json();
            // worldtimeapi returns datetime as ISO string
            const dt = j.datetime || j.utc_datetime || null;
            createLiveClockElement(`${city || country}`, j.timezone || zone, dt);
            return;
          }
        } catch {
          // continue to fallback
        }
      }

      // Fallback: use geocode + timeapi
      const geoQuery = [city, country].filter(Boolean).join(", ");
      const f = await timeByGeocode(geoQuery || country || city);
      if (f && f.datetime) {
        createLiveClockElement(`${city || country}`, f.timezone || f.provider || "unknown", f.datetime);
        return;
      }

      // If still not found
      const failCard = document.createElement("div");
      failCard.classList.add("result-card");
      failCard.innerHTML = `<strong>${city || country}</strong><br>‚ùå Could not determine timezone/time for this location. Try a different city or use exact city name (eg: Lagos, New_York).`;
      resultsDiv.appendChild(failCard);
    }

    // Get Time button
    getTimeBtn.addEventListener("click", async () => {
      // clear existing intervals
      liveIntervals.forEach(clearInterval);
      liveIntervals = [];
      resultsDiv.innerHTML = "";
      searchCount++;

      if (searchCount > 20) {
        premiumPrompt.style.display = "block";
        return;
      }

      const boxes = document.querySelectorAll(".country-box");
      // process sequentially to avoid overloading APIs ‚Äî still fast
      for (let box of boxes) {
        const continent = box.querySelector(".continent").value.trim();
        const country = box.querySelector(".country").value.trim();
        const city = box.querySelector(".city").value.trim();

        if (!city && !country) {
          const warn = document.createElement("div");
          warn.classList.add("result-card");
          warn.textContent = "‚ö†Ô∏è Please enter a city or a country.";
          resultsDiv.appendChild(warn);
          continue;
        }

        // try with both city and country inputs
        await handleSingleLocation(continent, country, city || country);
      }
    });

    // Use My IP (ipapi)
    useMyIPBtn.addEventListener("click", async () => {
      // clear intervals for previous clocks
      liveIntervals.forEach(clearInterval);
      liveIntervals = [];
      resultsDiv.innerHTML = `<div class="result-card">‚è≥ Detecting your IP and location...</div>`;
      try {
        const response = await fetch("https://ipapi.co/json/");
        const data = await response.json();

        if (data.error) throw new Error("IP Fetch Failed");

        resultsDiv.innerHTML = `
          <div class="result-card" id="ip-card">
            <strong>Your IP:</strong> ${data.ip}<br>
            <strong>City:</strong> ${data.city || "‚Äî"}<br>
            <strong>Country:</strong> ${data.country_name || "‚Äî"}<br>
            <strong>Timezone:</strong> ${data.timezone || "‚Äî"}<br>
            <div id="ip-clock">Loading time...</div>
          </div>
        `;

        // Show live clock using the timezone from ipapi (if present), otherwise fallback to geocode/timeapi
        if (data.timezone) {
          let ms = Date.now();
          function updateIP() {
            try {
              const formatted = new Date(ms).toLocaleString("en-US", { timeZone: data.timezone });
              document.getElementById("ip-clock").textContent = `Local Time: ${formatted}`;
            } catch {
              document.getElementById("ip-clock").textContent = `Local Time: ${new Date(ms).toLocaleString()}`;
            }
            ms += 1000;
          }
          updateIP();
          const ivi = setInterval(updateIP, 1000);
          liveIntervals.push(ivi);
        } else {
          // fallback: use timeapi via geocode
          const loc = [data.city, data.country_name].filter(Boolean).join(", ");
          const t = await timeByGeocode(loc || data.ip);
          if (t && t.datetime) {
            createLiveClockElement(`IP: ${data.ip}`, t.timezone || t.provider, t.datetime);
          } else {
            document.getElementById("ip-clock").textContent = "Could not determine local time.";
          }
        }
      } catch {
        resultsDiv.innerHTML = `<div class="result-card">‚ö†Ô∏è Error detecting your IP or time zone.</div>`;
      }
    });

    // Make the Paystack link use your subscription page (you said you want subscription link)
    paystackLink.href = "https://paystack.shop/pay/felixhub-premium";
  </script>
</body>
</html>
